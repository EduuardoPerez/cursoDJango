-------------------------------- CREAR PROYECTO ------------------------------

	El
	
		django-admin.py
	
	es la utilidad de linea de comandos de DJango, es la que nos apoya para poder crear proyectos, aplicaciones y super usuarios.

	Comandos:
		1- django-admin.py startproject nombre_del_proyecto
		2- django-admin.py startapp nombre_de_la_app
		2- django-admin.py createsuperuser


	El
	
		manage.py

	es un empaquetador de django-admin.py, nos ayuda a crear migraciones. Hacer
	migraciones, correr el servidor, o ver todo el SQL que se crean en las migraciones.

	Comandos:
		1- manage.py makemigrations
		2- manage.py migrations
		3- manage.py runserver


------------------------------------------------------------------------------

--------------- CREAR APLICACIONES Y ESTRUCTURA DEL PROYECTO -----------------

	Para ver la estructura del proyecto ver este video - video 2 - del curso

	Un proyecto en DJango es nuestra aplicacion web.

	Las aplicaciones que se crean con el comando

		django-admin.py startapp nombre_de_la_app

	Son aplicaciones que se crean dentro del proyecto de DJango, pero debemos saber
	distinguir entre lo que es nuestra aplicacion web (el proyecto en si) y una
	aplicacion de DJango (modulo o funcionalidad de nuestro proyecto (aplicacion
	web)).


------------------------------------------------------------------------------

--------------------------- MODELOS Y MIGRACIONES ----------------------------

	Un modelo es la fuente unica y definitiva de los datos de nuestra aplicacion
	Podemos definir un modelo como una tabla en nuestra base de datos

	Los modelos son clases que van a heredar de la clase

		django.db.models.Model

	Por eso tienen atributos, y los atributos van a corresponder a los campos de
	nuestra tabla.

	Cuando se crean los modelos, no es absolutamente necesario colocarle un ID,
	esto porque DJango le coloca de manera automatica un campo ID de tipo autoincrementable
	en la base de datos.

	Una llave, o clave primaria identifica de manera Ãºnica cada fila de una tabla.
	En los modelos de DJango se puede indicar cual sera esta al momento de crearlos.
	Esto indicando en uno de los atributos que ese sera la llave primaria, pasando
	como parametro primary_key=True:

		atributo = models.CharField(primary_key=True)

	de esta forma se dejaria de utilizar el ID que genera por defecto DJango y se
	comienza a utilizar esta para identificar los campos de la tabla.

------------------------------------------------------------------------------

-------------------------------- RELACIONES ----------------------------------

	- Relacion de uno a muchos, campo: ForeignKey
			Se define de la siguiente manera: despues de haber declarado nuestro modelo
			le asignamos la llave foranea como se muestra en el siguiente ejemplo:

				class Persona(models.Model):
					atributos...

				class Mascota(models.Model):
					persona = models.ForeignKey(Persona, null=True, blank=True, on_delete=models.CASCADE)
					atributos...

			Donde el atributo persona del modelo Mascota va a ser la llave foranea y
			le pasaremos como parametro el modelo al cual va a apuntar (Persona en este
			caso, el cual ya se definio con aterioridad), el parametro null=True permitira
			guardar valores nulos en la base de datos, el parametro blank=True permite
			guardar en la base de datos sin haber haber ingresado ningun dato en el
			campo persona, el argumento on_delete=models.CASCADE lo pasamos para que
			cuando se borre un registro del modelo Persona, automaticamente se eliminen los registros que estes relacionados con el.

	- Relacion uno a uno, campo: OneToOneField
			La manera en como lo aplicamos a los modelos es igual a como lo hicimos
			con la relacion de uno a muchos:

				class Persona(models.Model):
					atributos...

				class Mascota(models.Model):
					persona = models.OneToOneField(Persona, null=True, blank=True, on_delete=models.CASCADE)
					atributos...

	- Muchos a muchos, campo: ManyToManyField
			Cuando se trabaja con la relacion de muchos a muchos lo que sea hace es
			que se crea otra tabla que va a contener los id de ambas tablas.

			Por ejemplo, si tenemos un modelo llamado Vacuna y lo queremos relacionar
			con otro modelo llamado Mascota, seria algo como:

				Class Vacuna(models.Model):
					atributos...

				Class Mascota(models.Model):
					vacuna = models.ManyToManyField(Vacuna)
					atributos...

	En DJango podemos registrar nuestros modelos para que podamos manipularlos desde
	el administrador que nos trae este framework. Para esto, escribiremos en el
	archivo admin que se encuentra dentro de cada aplicacion:

		admin.site.register(modelo)

	Luego de haberlo importado.

------------------------------------------------------------------------------

------------------------- DJango Shell y Querysets ---------------------------

	El api shell de DJango nos brinda la facilidad de poder interactuar con nuestros
	modelos y objetos mediante el.

	Los querysets, permiten realizar lecturas, filtrado y ordenamientos en la base
	de datos.

	Lo primero que se hace al querer interactuar con los modelos, es importarlos



	El shell de DJango inicia con el comando

		manage.py shell

	Y los modelos se importan de igual manera que como se hace en los .py

		from directorio.aplicacion.models import Modelo


	Para registrar un objeto desde el shell de DJango se puede hacer de dos maneras:

		- Modelo.objects.create(atributo1 = valor,
														atributo2 = valor,
																		-
																		-
																		-
														atributo n = valor)

		- Asignar a una variable los atributos del modelo

				variable = Modelo(atributo1 = valor,
												  atributo2 = valor,
															    -
																	-
																	-
													atributo n = valor)

			Se guarda el objeto con

				variable.save()


	Desde el shell de DJango se puede asignar la llave foranea a un objeto de la
	BD.

	Con el Queryset:

		Modelo.objects.all()

	se muestra en el shell los objetos que hay en el Modelo


	Se puede filtrar utilizando el metodo filter:

		Modelo.objects.filter(valor_para_filtrar)

		por ejemplo

		Persona.objects.filter(id=2)
		Persona.objects.filter(nombre__contains="Jose")



		Ejemplo del uso del Shell

			(curDJango) D:\Cursos\codigofacilito\DJango\cursoDjango>manage.py shell
			Python 3.7.0 (v3.7.0:1bf9cc5093, Jun 27 2018, 04:06:47) [MSC v.1914 32 bit (Intel)] on win32
			Type "help", "copyright", "credits" or "license" for more information.
			(InteractiveConsole)
			>>> from apps.mascota.models import Vacuna, Mascota
			>>> from apps.adopcion.models import Persona
			>>> Persona.objects.create(nombre = "Eduardo",
			... apellidos = "Perez",
			... edad = 23,
			... telefono = "1165801254",
			... email = "edujpp1@gmail.com",
			... domicilio = "Libertad 942")
			<Persona: Persona object (1)>
			>>> variable = Persona(nombre = "Eduardo Jose",
			... apellidos = "Perez Pe#a",
			... edad = 23,
			... telefono = "1165801254",
			... email = "edujpp@hotmail.com",
			... domicilio = "Argentina")
			>>> variable.save()
			>>> mascota1 = Mascota(nombre = "Luca",
			... sexo = "Macho"
			... , edad_aproximada = 2,
			... fecha_rescate = "2018-07-24",
			... persona = variable)
			>>> mascota1.save()
			>>> v1 = Vacuna(nombre = "vacuna 1")
			>>> v1.save()
			>>> v2 = Vacuna(nombre = "vacuna 2")
			>>> v2.save()
			>>> mascota1.vacuna.add(v1, v2)
			>>> Persona.objects.all()
			<QuerySet [<Persona: Persona object (1)>, <Persona: Persona object (2)>]>
			>>> Persona.objects.filter(id=2)
			<QuerySet [<Persona: Persona object (2)>]>
			>>> Persona.objects.filter(nombre__contains="Jose")
			<QuerySet [<Persona: Persona object (2)>]>
			>>> exit()

------------------------------------------------------------------------------

--------------------- CONFIGURAR URLS Y PRIMERA VIEW -------------------------

	Para comenzar a crear las vistas, iremos al archivo views.py. En el, importaremos la clase HttpResponse con la sentencia

		from django.http import HttpResponse

	En el archivo settings.py que se crea cuando creamos el proyecto tenemos la variable 

		ROOT_URLCONF

	Que es a la que se le asigna lo que son las URLS globales de nuestro proyecto
 que se encuentran en el mismo directorio, en el archivo urls.py.


	En el archivo

		urls.py

	Es donde podemos incluir las urls de cada una de nuestras aplicaciones. Pero,
	para yo poder incluir las urls de las apps, hay que crear en la app, un archivo que se llame urls.py. Este tendra un contenido similar al que es generado
	por python en el archivo url.py global.

	Dentro de la variable

		urlpatterns

	Sera en donde vamos a listar las urls de las aplicaciones. Seria al como

		from django.contrib import admin
		from apps.mascota.views import index

		urlpatterns = [
		    path('', index),
		]

	En el metodo path, el primer parametro es la url, como en este caso es un index
	se coloca vacio.
	El segundo parametro es la vista que se va a ejecutar al momento en que reciba
	esa peticion de la url.

	Para poder incluir estas urls en las urls globales. Se crea una url en el archivo global de urls y se le indica que url incluira:

		urlpatterns = [
		    path('admin/', admin.site.urls),
		    path('admin/', include('apps.mascota.url')),
		]


------------------------------------------------------------------------------

----------------------------- SISTEMA PLANTILLAS -----------------------------

	Los sistemas de plantillas permiten separar todo lo que es la logica de nuestra
	aplicacion, del aspecto visual, lo que viene siendo nuestro HTML.

	Herramientas del sistema de plantillas de DJango:
		- Variables
		- Tags (etiquetas)
		- Herencia 


	Las VARIABLES las vamos a identificar porque van a estar encerradas entre llaves dobles, ejm:

		<tbody>
			<tr>
				<td>{{ mascota.nombre }}</td>
				<td>{{ mascota.edad_aproximada }}</td>
				<td>{{ mascota.fecha_rescate }}</td>
			</tr>
		</tbody>

	Esto lo vamos a utilizar cuando queramos renderizar, o mostrar, valores que 
	hemos enviado en el contexto (informacion enviada por la vista al template)
	de nuestras vistas.



	Los TAGS se encuentran encerrados entre llaves y signos de porcentajes. Por
	ejemplo con el flujo de control for, seria:

		<tbody>
			{% for mascota in mascotas %}
				<tr>
					<td>{{ mascota.nombre }}</td>
					<td>{{ mascota.edad_aproximada }}</td>
					<td>{{ mascota.fecha_rescate }}</td>
				</tr>
			{% endfor %}
		</tbody>

	Estos nos brindan la facilidad de realizar flujo de control o carga informacion
	externa de los templates.

	Un ejemplo con la sentencia if, seria:

		<tbody>
			{% if mascotas %}
			{% for mascota in mascotas %}
				<tr>
					<td>{{ mascota.nombre }}</td>
					<td>{{ mascota.edad_aproximada }}</td>
					<td>{{ mascota.fecha_rescate }}</td>
				</tr>
			{% endfor %}
			{% else %}
				<h4> No existen registros de mascotas </h4>
			{% endif %}
		</tbody>

		El tag de load staticfiles nos va a servir en todos nuestros templates para
		cargar, o servir, nuestro archivos estaticos, que se debe colocar unicamente
		antes de cargar los archivos estaticos. Ejm:

			<!DOCTYPE html>
			<html lang="es">
			<head>
				{% load staticfiles %}
				<meta charset="utf-8">
				<title>Document</title>
				}
			</head>
			<body>
			
			</body>
			</html>



	La HERENCIA DE PLANTILLAS, reduce la duplicacion y redundancia de elementos
	comunes de los templates, como un title, un header, un navbar, un footer.

	Gracias a la herencia de plantillas, lo que haremos sera crear un esceleto o
	un documento base el cual va a contener estos elementos que necesitan replicarse,
	y en nuestros otros templates podremos heredar estas plantillas, mediante otro
	tag que se llama extends, y asi extendiendo del archivo base podremos sobreescribir
	toda esta parte de la estructura.

	La ubicacion de las plantillas se le indican a DJango desde el archivo

		settings.py

	buscar la variable

		TEMPLATES

	dentro de ella buscaremos el elemeto

		DIRS

	y dentro del arreglo escribiremos

		os.path.join(BASE_DIR, 'templates')

	que quiere decir: buscame una carpeta que se llama templates que esta en la
	raiza de la carpeta contenedora del proyecto.

	El elemento

		APP_DIRS

	que se encuentra dentro de la variable TEMPLATES, cuando esta en True, quiere
	decir que cuando se busque un template tambien lo va a buscar dentro de la carpeta
	de cada una de nuestras aplicaciones, es decir, podemos organizar nuestros templates de dos maneras:

		1- Una sola carpeta en la raiz de la carpeta contenedora de nuestro proyecto
		donde podemos almacenar todos nuestros templates.
		2- En cada aplicacion, dentro de ella, generamos otro directorio que se llame
		templates, el cual va a contener nuestros templates de nuestras aplicaciones.

------------------------------------------------------------------------------

------------------------- HERENCIA DE PLANTILLAS -----------------------------

	Se hereda entre templates con el tag extendes, mediante la siguiente sintaxis

		{% extends 'ruta/template.html' %}


	Desde las vistas, se llaman a los templates utilizando el shortcuts render,
	por ejm:

		def index(request):
			return render(request, 'ruta/template.html')

	Para sobreescribir los bloques de las plantillas heredadas se abre y se cierra
	el bloque en la platnilla que esta heredando y se colcoa el contenido que se
	quiere tener.

	El sistema de plantillas de DJango tambien nos permite hacer includes. Esto
	el tag include:

		{% include 'ruta/template.html' %}

	Sin embargo, no es muy recomendable.


	En los templates base no es muy recomendable cargar los archivos CSS y JS
	que vamos	a utilizar, pues, puede suceder que hayan templates donde no haga
 	falta cargar todos estos archivos. Una buena practica es crear un bloque 'extrahead'
 	para colocar luego en los templates los CSS y un extrajs para colocar los JS.

------------------------------------------------------------------------------

----------------------- CONFIGURAR ARCHIVOS ESTATICOS ------------------------

	Para indicarle a DJango donde tiene que buscar nuestros archivos estaticos debemos
	ir al documento

		settings.py
	
	Declaramos otra variable, que se llamara

		STATICFILES_DIRS

	Y le indicaremos donde tiene que buscar los archivos:

		STATICFILES_DIRS = (os.path.join(BASE_DIR, 'nombre_de_la_carpeta_donde_estan_los_archivos_estaticos'), )

	La etiqueta static

		<link rel="stylesheet" href="{% static 'css/boostrap.min.css' %}">
		<script src="{% static 'js/boostrap.min.js' %}"></script>

	Es necesaria para poder hacer referencia a todos nuestros archivos estaticos.
	El tag static lo que hace es arrojar la ruta absoluta donde se encuentra alojado
	el archivo.

------------------------------------------------------------------------------

-------------- FORMULARIOS Y VISTAS BASADAS EN FUNCIONES CREAR ---------------

	Se crearan formularios para agregar registros a nuestros modelos.

	Los forms de DJango se importan con

		from django import forms

	Y se puede utilizar en funciones como:

		class NombreFuncion(forms.ModelForm)

	Se crea una clase meta dentro de la clase anterior y aca se le indica de que
	modelo va a ser el formulario

		class NombreFuncion(forms.ModelForm):

			class Meta:
				model = NombreModelo

	Los campos que queremos que tenga nuestro formulario se agregan como una lista
	por medio de declarar fiels:

		class MascotaForm(forms.ModelForm):

		class Meta:
			model = NombreModelo

			fields = [
				'campo1',
				'campo2',
				'   -  ',
				'   -  ',
				'   -  ',
				'campoN',
			]

	Luego se agregan los labels que tendran cada cada campo

		class Meta:
			model = NombreModelo

			fields = [
				'campo1',
				'campo2',
				'   -  ',
				'   -  ',
				'   -  ',
				'campoN',
			]
			labels = {
				'campo1': 'descripcion1',
				'campo2': 'descripcion2',
				'   -  ': '      -     ',
				'   -  ': '      -     ',
				'   -  ': '      -     ',
				'campoN': 'descripcionN',
			}

	Y por ultimo los widgets, que son las etiquetas HTML que veremos en el navegador
	pueden ser TextInput, select, CheckBox y etiquetas especiales que trae DJango:

		class Meta:
			model = NombreModelo

			fields = [
				'campo1',
				'campo2',
				'   -  ',
				'   -  ',
				'   -  ',
				'campoN',
			]
			labels = {
				'campo1': 'descripcion1',
				'campo2': 'descripcion2',
				'   -  ': '      -     ',
				'   -  ': '      -     ',
				'   -  ': '      -     ',
				'campoN': 'descripcionN',
			}
			widgets = {
				'campo1',: forms.TipoDeEtiquetaHTML(attrs={'parametroCSS':'valorDelParametroCSS'}),
				'campo2',: forms.TipoDeEtiquetaHTML(attrs={'parametroCSS':'valorDelParametroCSS'}),
															-
															-
															-
				'campoN',: forms.TipoDeEtiquetaHTML(attrs={'parametroCSS':'valorDelParametroCSS'}),
			}


	Una vez que se crea el formulario, se procede con la vista. Que sera la que
	va a recibir la peticion y se va a ejecutar. Por ahora trabajaremos con vistas
	basadas en funciones. Las vistas basadas en funciones, son de versiones antiguas
	de DJango, pero no esta demas conocerlas, pues su uso es poco, pero lo hay.

	Un ejemplo de vista seria:

		def mascota_view(request):
			if request.method == 'POST':
				form = MascotaForm(request.POST)
				if form.is_valid():
					form.save()
				return redirect('mascota:index')
			else:
				form = MascotaForm()
			return render(request, 'mascota/mascota_form.html', {'form':form})


	Que en pseudocodigo seria

		- Definicion de la vista basada en funcion
			- Si el request es un POST
				- Se recibiran los datos que se estan enviando en el POST de nuestro form
				- Si los datos ingresados son validos
					Se guardan
				- Se redirige a ('NombreDeEspacio':'Url')
			- Sino
				- Se vuelve a cargar el form
			- Se retorna la respuesta con render(request, 'nombreDelTemplate', {'contexto':contenido})


	El formulario se importaria en la vista con

		from apps.mascota.forms import MascotaForm

	Para que la vista sea redirigida con la sentencia

		return redirect('mascota:index')

	Es necesario ya haber declarado el espaciado de nombre de 'mascota' en el archivo principal settings.py con la sentencia

		path('mascota/', include(('apps.mascota.urls', 'mascota'), namespace="mascota")),

	Y para utilizar el 'index', se debe agregar en la variable urlpatterns del 
	archivo urls.py de la apps mascotas la sentencia:

	urlpatterns = [
    path('', index, name='index'),
    path('nuevo', mascota_view, name='mascota_crear'),
	]

	Es igual para cualquier otra vista o app.


	para que funcione el shortcut redirec se debe agregar con

		from django.shortcuts import redirect

		o, si son varios shortcuts:

			from django.shortcuts import render, redirect



	Luego si se puede modificar el template para indicar como se vera el form con
	algo tan sencillo como:

		{% extends 'base/base.html' %}

		{% block content %}
			<form method="post">
				{% csrf_token %}
				{{ form.as_p }}
				<button type="submit">Guardar</button>
			</form>
		{% endblock %}


	Hay que recordar que en nuestra vista le estamos enviando el contexto, que es
	nuestro form, en la ultima sentencia

		return render(request, 'mascota/mascota_form.html', {'form':form})

	En la sentencia

		{{ form.as_p }}

	Estamos metiendo en una variable el form que estamos recibiendo en el contexto y con el 'as_p' se le esta indicando que se dibujara en el navegador
	el form como parrafo. Es decir, dentro de puras etiquetas HTML <p>

	Tambien podriamos crear los divs de 'form-group' y acceder a cada elemento del
	form de la manera:

		{{ form.nombreDelAtributo }}

	Y mostraria en el navegador solo esa etiqueta.

	El token de seguridad que nos provee DJango

		{% csrf_token %}	

	es muy importante incluirlo en todos los formularios, comenzando porque si no
	lo hacemos, nos marcara un error.


	Para que la llave foranea (persona) y el campo ManyToMany (vacuna) muestren
	su contenido y no los objetos como tal se debe agregar en los models la funcion

		def __str__(self):
			return "{} {}".format(self.nombre, self.nombre)

	Esto devolvera en el modelo de la app adopcion cuando se acceda al objeto,
	los atributos del primer y segundo campo

	Y en la app mascota, en el modelo vacuna

		def __str__(self):
			return '{}'.format(self.nombre)

	Devolvera el nombre de la vacuna.

------------------------------------------------------------------------------

--------------- LISTAR REGISTROS (VISTAS BASADAS EN FUNCIONES) ---------------

	Vista de ejemplo

	def mascota_list(request):
		mascota = Mascota.objects.all()
		contexto = {'mascotas':mascota}
		return render(request, 'mascota/mascota_list.html', contexto)

	En pseudocodigo:

		- Definicion de la vista basada en funcion
			- Definicion del QuerySet trayendo todos los objetos que estan en el modelo mascota
			- Envio del QuerySet en la variable contexto, que tendra asignado el diccionario
			- Retorno de la respuesta con render(request, 'nombreDelTemplate', variable)


	Luego, para mostrar en el HTML lo que contiene el modelo se utilizo para este 
	ejm el archivo HTML, en el cual un trozo de codigo es:

		{% if mascotas %}
			{% for mascota in mascotas %}
				<tr>
					<td>{{ mascota.id }}</td>
					<td>{{ mascota.nombre }}</td>
					<td>{{ mascota.sexo }}</td>
					<td>{{ mascota.edad_aproximada }}</td>
					<td>{{ mascota.fecha_rescate }}</td>
					<td>{{ mascota.persona.nombre }} {{ mascota.persona.apellidos }}</td>
				</tr>
			{% endfor %}
		{% else %}
			<h1>No hay mascotas registradas</h1>
		{% endif %}

	En pseudo codigo:

		- Si existen registros en nuestro contexto
			- Para mascota en el contexto 'mascotas' (O generar el ciclo for para generar
				un tr por cada registro de la tabla)
				- Trae de mascota el id al td
				- Trae de mascota el nombre al td
				- Trae de mascota el sexo al td
				- Trae de mascota la fecha de rescate al td
				- Trae de mascota el nombre y apellidos de la persona al td
			- Fin del ciclo for
		- Sino
			- Genera el h1 que dice: No hay mascotas registradas
		- Fin del if

		Esta es una manera muy sencilla de listar los registros de nuestros modelos.

------------------------------------------------------------------------------

------------- VISTAS BASADAS EN FUNCIONES ACTUALIZAR Y ELIMINAR --------------

	Se creo la vista para editar un modelo de la app mascota

	def mascota_edit(request, id_mascota):
		mascota = Mascota.objects.get(id=id_mascota)
		if request.method == 'GET':
			form = MascotaForm(instance=mascota)
		else:
			form = MascotaForm(request.POST, instance=mascota)
			if form.is_valid():
				form.save()
			return redirect('mascota:mascota_listar')
		return render(request, 'mascota/mascota_form.html', {'form':form})

	En pseudocodigo:

	- Definicion de la vista basada en funcion que recibe el parametro request y un id
		- Se crea el QuerySet que obtendra el objeto al cual corresponde el objeto
			que se le esta enviando
		- Si el metodo es un GET
			- Cargara la informacion del form con una instancia del obj que se cargo
				en la variable mascota con el QuerySet
		- Sino
			- Toma el POST del form y se instancia el obj mascota que fue el que capturamos
				para que se guarden los cambios que estamos mandando
			- Si el form es valido
				- Guarda los cambios
			- Redirige al listado de las mascotas
		- Se retorna un render al mismo template que se utiliza para registrar mascotas
			enviando como contexto el form


	Para que la url sea dinamica y muestre el form con los datos cargados de la
	mascota seleccionada se coloca

		path('editar/<int:id_mascota>/', mascota_edit, name='mascota_editar'),

	Con la expresion regular

		<int:id_mascota>

	Recibe el segundo parametro que le estamos enviando.



	Para llegar a la vista de editar se agrego en el mascota_list.html un boton
	que redirige a la url de editar:

		<a class="btn btn-primary" href="{% url 'mascota:mascota_editar' mascota.id %}">Editar</a>

	Se redirecciona en el tag url

		{% url 'mascota:mascota_editar' mascota.id %}

	Que recibe como primer parametro la url que creamos para editar y como segundo
	parametro el id de la mascota


	El codigo para eliminar es relativamente similar:

	def mascota_delete(request, id_mascota):
		mascota = Mascota.objects.get(id=id_mascota)
		if request.method == 'POST':
			mascota.delete()
			return redirect('mascota:mascota_listar')
		return render(request, 'mascota/mascota_delete.html', {'mascota':mascota})

	En pseudocodigo

	- Definicion de la vista basada en funcion que recibe el parametro request y un id
		- Se crea el QuerySet que obtendra el objeto al cual corresponde el objeto
			que se le esta enviando
		- Si el metodo es un POST
			- Llamamos al obj que obtuvimos y lo eliminamos
			- Retorna al listado
		- Retorna un render al template delete enviando como contexto el obj mascota


	Se puede organizar la tabla para que salga ordenada por el id. Esto es con:

		mascota = Mascota.objects.all().order_by('id')

------------------------------------------------------------------------------